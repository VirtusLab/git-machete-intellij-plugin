package com.virtuslab.archunit;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

import java.util.HashSet;
import java.util.Set;

import javax.xml.parsers.DocumentBuilderFactory;

import com.tngtech.archunit.core.domain.JavaAccess;
import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.lang.ArchCondition;
import com.tngtech.archunit.lang.ConditionEvents;
import com.tngtech.archunit.lang.SimpleConditionEvent;
import lombok.SneakyThrows;
import lombok.val;
import org.junit.Test;

public class ClassStructureTestSuite extends BaseArchUnitTestSuite {

  @Test
  public void actions_implementing_DumbAware_should_extend_DumbAwareAction() {
    classes()
        .that().areAssignableTo(com.intellij.openapi.actionSystem.AnAction.class)
        .and().implement(com.intellij.openapi.project.DumbAware.class)
        .should().beAssignableTo(com.intellij.openapi.project.DumbAwareAction.class)
        .because("`extends DumbAwareAction` should be used instead of " +
            "extending `AnAction` and implementing `DumbAware` separately")
        .check(importedClasses);
  }

  static class BeReferencedFromOutsideItself extends ArchCondition<JavaClass> {

    BeReferencedFromOutsideItself() {
      super("is not referenced from any other compilation units");
    }

    @Override
    public void check(JavaClass javaClass, ConditionEvents events) {
      Set<JavaAccess<?>> accessesFromOtherCompilationUnits = new HashSet<>(javaClass.getAccessesToSelf());
      accessesFromOtherCompilationUnits.removeAll(javaClass.getAccessesFromSelf());

      if (accessesFromOtherCompilationUnits.isEmpty() && javaClass.getDirectDependenciesToSelf().isEmpty()) {
        String message = javaClass.getDescription() + " is NOT referenced from any other class";
        events.add(new SimpleConditionEvent(javaClass, /* conditionSatisfied */ false, message));
      }
    }
  }

  @SneakyThrows
  private Set<Class<?>> extractAllClassesReferencedFromPluginXmlAttributes() {
    val classLoader = Thread.currentThread().getContextClassLoader();
    val documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();;
    val document = documentBuilder.parse(classLoader.getResourceAsStream("META-INF/plugin.xml"));
    val nodeList = document.getElementsByTagName("*");
    Set<Class<?>> result = new HashSet<>();
    for (int i = 0; i < nodeList.getLength(); i++) {
      val node = nodeList.item(i);
      val attributes = node.getAttributes();
      for (int j = 0; j < attributes.getLength(); j++) {
        val attribute = attributes.item(j);
        val maybeFqcn = attribute.getNodeValue();
        try {
          val clazz = Class.forName(maybeFqcn, /* initialize */ false, classLoader);
          result.add(clazz);
        } catch (ClassNotFoundException e) {
          // Not all XML attributes found in plugin.xml correspond to class names,
          // let's ignore those that don't.
        }
      }
    }
    return result;
  }

  @Test
  public void all_classes_should_be_referenced() {
    val classesReferencedFromPluginXmlAttributes = extractAllClassesReferencedFromPluginXmlAttributes().toArray(Class[]::new);
    classes()
        .that().resideOutsideOfPackages(
            // Classes in *.impl.* packages may be instantiated via RuntimeBinding
            "..impl..",
            // For some reason, ArchUnit (com.tngtech.archunit.core.domain.JavaClass.getAccessesFromSelf)
            // doesn't see accesses to static fields
            "com.virtuslab.gitmachete.frontend.defs")
        .and().doNotBelongToAnyOf(classesReferencedFromPluginXmlAttributes)
        // SubtypingBottom is processed by CheckerFramework based on its annotations
        .and().doNotHaveFullyQualifiedName(com.virtuslab.qual.internal.SubtypingBottom.class.getName())
        .should(new BeReferencedFromOutsideItself())
        .check(importedClasses);
  }

  @Test
  public void inner_classes_should_not_be_used() {
    noClasses()
        .that().haveNameNotMatching("^.*\\$[0-9]+$") // inner classes autogenerated by the compiler
        .and()
        .haveNameNotMatching("^" + com.virtuslab.gitmachete.frontend.actions.dialogs.GitPushDialog.class.getName() + "\\$.*$")
        .and()
        .haveNameNotMatching("^" + com.virtuslab.gitmachete.frontend.actions.dialogs.OverrideForkPointDialog.class.getName()
            + "\\$WhenMappings$")
        .should().beInnerClasses()
        .because("inner (non-static nested) classes are currently unsafe & discouraged " +
            "due to https://github.com/typetools/checker-framework/issues/3407; " +
            "consider using a static nested class " +
            "and passing a reference to the enclosing object (or to the fields thereof) explicitly")
        .check(importedClasses);
  }

}
