plugins {
  id 'org.gradle.checkstyle'
  id 'org.gradle.java-library'
  id 'org.gradle.scala'
  id 'groovy'

  alias libs.plugins.taskTree
  alias libs.plugins.versions
  alias libs.plugins.versionCatalogUpdate

  alias libs.plugins.aspectj.postCompileWeaving apply false
  alias libs.plugins.checkerFramework apply false
  alias libs.plugins.grgit apply false
  alias libs.plugins.jetbrains.grammarkit apply false
  alias libs.plugins.jetbrains.intellij apply false
  alias libs.plugins.jetbrains.kotlin apply false
  alias libs.plugins.spotless apply false
}

if (JavaVersion.current() != JavaVersion.VERSION_11) {
  throw new GradleException("Project must be built with Java version 11")
}

import com.virtuslab.gitmachete.buildsrc.IntellijVersionHelper

ext {
  javaMajorVersion = JavaVersion.VERSION_11

  Properties intellijVersionsProp = IntellijVersionHelper.getProperties()

  // See https://www.jetbrains.com/intellij-repository/releases/ -> Ctrl+F .idea
  intellijVersions = [
    // When this value is updated, remember to update the minimum required IDEA version in README.md.
    earliestSupportedMajor: intellijVersionsProp.getProperty("earliestSupportedMajor"),
    // Most recent minor versions of all major releases
    // between earliest supported (incl.) and latest stable (excl.), used for binary compatibility checks and UI tests
    latestMinorsOfOldSupportedMajors: Arrays.asList(intellijVersionsProp.getProperty("latestMinorsOfOldSupportedMajors").split(",")),
    latestStable: intellijVersionsProp.getProperty("latestStable"),
    // Note that we have to use a "fixed snapshot" version X.Y.Z-EAP-SNAPSHOT (e.g. 211.4961.33-EAP-SNAPSHOT)
    // rather than a "rolling snapshot" X-EAP-SNAPSHOT (e.g. 211-EAP-SNAPSHOT)
    // to ensure that the builds are reproducible.
    // EAP-CANDIDATE-SNAPSHOTs can be used for binary compatibility checks,
    // but for some reason aren't resolved in UI tests.
    // Generally, see https://www.jetbrains.com/intellij-repository/snapshots/ -> Ctrl+F .idea
    // Use `null` if the latest supported major has a stable release (and not just EAPs).
    eapOfLatestSupportedMajor: intellijVersionsProp.getProperty("eapOfLatestSupportedMajor")
  ]

  intellijVersions.latestSupportedMajor = intellijVersions.eapOfLatestSupportedMajor
    ? IntellijVersionHelper.getFromBuildNumber(intellijVersions.eapOfLatestSupportedMajor)
    : IntellijVersionHelper.getMajorPart(intellijVersions.latestStable)

  intellijVersions.buildTarget = intellijVersions.eapOfLatestSupportedMajor ?: intellijVersions.latestStable

  ciBranch = System.getenv('CIRCLE_BRANCH')
  isCI = System.getenv('CI') == 'true'
  jetbrainsMarketplaceToken = System.getenv('JETBRAINS_MARKETPLACE_TOKEN')

  // This values can't be named in the same way as their corresponding properties to avoid a name clash.
  jvmArgsForJavaCompilation = project.properties.get('compileJavaJvmArgs')?.tokenize(' ')
  shouldRunAllCheckers = isCI || project.hasProperty('runAllCheckers')
}

/**
 * @param versionKey Either release number (like 2020.3) or key of intellijVersions (like eapOfLatestSupportedMajor)
 * @returns Corresponding release numbers.
 */
List<String> resolveIntelliJVersions(String versionKey) {
  if (versionKey == null) {
    return []
  }
  if (versionKey =~ /^[0-9].*$/) {
    return [versionKey]
  }

  def versionValue = project.intellijVersions.get(versionKey)
  if (!versionValue) {
    return []
  }
  if (versionValue instanceof List) {
    return versionValue
  }
  return [versionValue]
}

import com.virtuslab.gitmachete.buildsrc.UpdateEapBuildNumber

tasks.register('updateEapBuildNumber', UpdateEapBuildNumber)

dependencyUpdates {
  def isStableVersion = { String version ->
    def stableKeyword = ['RELEASE', 'FINAL', 'GA'].any { version.toUpperCase().contains(it) }
    def regex = /^[0-9,.v-]+(-r)?$/
    return stableKeyword || version ==~ regex
  }

  rejectVersionIf {
    !isStableVersion(it.candidate.version)
  }
}


import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

allprojects {
  repositories {
    mavenLocal()
    mavenCentral()
  }

  apply plugin: 'org.gradle.java-library'

  sourceCompatibility = javaMajorVersion
  targetCompatibility = javaMajorVersion // redundant, added for clarity

  // String interpolation support, see https://github.com/antkorwin/better-strings
  // This needs to be enabled in each subproject by default because there's going to be no warning
  // if this annotation processor isn't run in any subproject (the strings will be just interpreted verbatim, without interpolation applied).
  // We'd only capture that in CI's post-compile checks by analyzing constants in class files.
  dependencies {
    annotationProcessor libs.betterStrings
    testAnnotationProcessor libs.betterStrings
  }

  tasks.withType(JavaCompile) {
    options.compilerArgs += [
      '-AcallToStringExplicitlyInInterpolations', // Enforce explicit `.toString()` call in code generated for string interpolations
      '-Werror', // Treat each compiler warning (esp. the ones coming from Checker Framework) as an error.
      '-Xlint:unchecked', // Warn of type-unsafe operations on generics.
    ]

    options.fork = true
    options.forkOptions.jvmArgs += jvmArgsForJavaCompilation ?: (isCI ? [] : ['-Xmx6G', '-XX:+HeapDumpOnOutOfMemoryError'])

    // `sourceCompatibility` and `targetCompatibility` say nothing about the Java APIs available to the compiled code.
    // In fact, for X < Y it's perfectly possible to compile Java X code that uses Java Y APIs...
    // This will work fine, until we actually try to run those compiled classes under Java X-compatible JVM,
    // when we'll end up with NoSuchMethodError for APIs added between Java X and Java Y
    // (i.e. for X=8 and Y=11: InputStream#readAllBytes, Stream#takeWhile and String#isBlank).
    // `options.release = X` makes sure that regardless of Java version used to run the compiler,
    // only Java X-compatible APIs are available to the compiled code.
    options.release = Integer.parseInt(javaMajorVersion.majorVersion)
  }

  tasks.withType(Javadoc) {
    // See JDK-8200363 (https://bugs.openjdk.java.net/browse/JDK-8200363) for information about the `-Xwerror` option:
    // this is needed to make sure that javadoc always fails on warnings
    // (esp. important on CI since javadoc there for some reason seems to never raise any errors otherwise).

    // The '-quiet' as second argument is actually a hack around https://github.com/gradle/gradle/issues/2354:
    // since the one-parameter `addStringOption` doesn't seem to work, we need to add an extra `-quiet`, which is added anyway by Gradle.
    options.addStringOption('Xwerror', '-quiet')
    options.addStringOption('Xdoclint:all', '-quiet')
  }

  tasks.withType(Test) {
    testLogging {
      events TestLogEvent.FAILED
      exceptionFormat TestExceptionFormat.FULL
      showCauses true
      showExceptions true
      showStackTraces true
    }
  }


  apply plugin: 'com.diffplug.spotless'
  spotless {
    java {
      importOrder 'java', 'javax', '', 'com.virtuslab'
      // See https://github.com/diffplug/spotless/blob/master/ECLIPSE_SCREENSHOTS.md on importing and exporting settings from Eclipse
      eclipse().configFile "$rootDir/config/spotless/formatting-rules.xml"
      removeUnusedImports()
      targetExclude '**/build/generated/**/*.*'
    }
    kotlin {
      ktfmt()
    }
    scala {
      scalafmt().configFile("$rootDir/scalafmt.conf")
    }
    groovy {
      target '/buildSrc/**/*.groovy', '/buildSrc/*.gradle'
      greclipse().configFile "$rootDir/config/spotless/formatting-rules.xml"
    }
  }

  if (!isCI) {
    tasks.withType(JavaCompile) {
      dependsOn 'spotlessJavaApply'
    }
    tasks.withType(KotlinCompile) {
      dependsOn 'spotlessKotlinApply'
    }
    tasks.withType(ScalaCompile) {
      dependsOn 'spotlessScalaApply'
    }
    tasks.withType(GroovyCompile) {
      dependsOn 'spotlessGroovyApply'
    }
  }


  apply plugin: 'org.checkerframework'
  checkerFramework {
    excludeTests = true
    checkers = [
      'org.checkerframework.checker.nullness.NullnessChecker',
    ]
    if (shouldRunAllCheckers) {
      // The experience shows that the below checkers are just rarely failing, as compared to GuiEffect/Nullness.
      // Hence, they're only applied in CI, or locally only if a dedicated Gradle project property is set.
      checkers += [
        'org.checkerframework.checker.index.IndexChecker',
        'org.checkerframework.checker.interning.InterningChecker',
        'org.checkerframework.checker.optional.OptionalChecker',
      ]
    }
    extraJavacArgs = [
      '-AassumeAssertionsAreEnabled',
      '-AinvariantArrays',
      '-Alint=cast:redundant,cast:unsafe',
      '-ArequirePrefixInWarningSuppressions',
      '-AshowSuppressWarningsStrings',
      "-Astubs=$rootDir/config/checker/",
      // The `-AstubWarnIfNotFoundIgnoresClasses` flag is required since Checker 3.14.0,
      // the version since which `-AstubWarnIfNotFound` is assumed to be true for custom stub files.
      // Without this flag, we would end up with a lot of errors in subprojects where any of the stubbed libraries is NOT on the classpath:
      // e.g. compilation of a subproject where Vavr is NOT a dependency would fail
      // since for simplicity, we're providing the same set of stubs to Checker in each subproject
      // (`$rootDir/config/checker/`, which includes e.g. Vavr).
      '-AstubWarnIfNotFoundIgnoresClasses',
      '-AsuppressWarnings=allcheckers:type.anno.before.decl.anno,allcheckers:type.anno.before.modifier,allcheckers:type.checking.not.run,value:annotation',
    ]
    dependencies {
      compileOnly      libs.checker.qual
      checkerFramework libs.checker
    }
  }


  apply plugin: 'org.gradle.checkstyle'
  checkstyle {
    checkstyleTest.enabled = false

    configProperties = [rootCheckstyleConfigDir: "$rootDir/config/checkstyle"]
  }


  // A few libraries (like JGit and reflections) transitively pull in a version of slf4j-api
  // that might be different from the slf4j-api version that IntelliJ depends on.
  // SLF4J guarantees that the code compiled against a certain slf4j-api version will work with any other version of slf4j-api
  // (http://www.slf4j.org/manual.html#compatibility).
  // We rely on that guarantee: our plugin effectively uses whatever slf4j-api version is provided by IntelliJ.
  // SLF4J does NOT guarantee, however, that slf4j-api version X will work with any slf4j implementation version Y for X != Y.
  // To avoid a clash between JGit&co.'s slf4j-api and Intellij's slf4j implementation
  // (and also between JGit&co.'s slf4j-api and Intellij's slf4j-api), we need to exclude the former from ALL dependencies.
  configurations.runtimeClasspath {
    exclude group: 'org.slf4j', module: 'slf4j-api'
  }

  ext {
    addIntellijToCompileClasspath = { Map params ->
      def tasksBefore = []
      tasksBefore.addAll(project.tasks)

      apply plugin: 'org.jetbrains.intellij'

      def tasksAfter = []
      tasksAfter.addAll(project.tasks)
      tasksAfter.removeAll(tasksBefore)
      // For the frontend subprojects we only use gradle-intellij-plugin to provide dependencies,
      // but don't want the associated tasks to be available; they should only be available in the root project.
      tasksAfter.each { it.enabled = false }
      // The only task (as of gradle-intellij-plugin v1.7.0, at least) that needs to be enabled in all IntelliJ-aware modules
      // is `classpathIndexCleanup`, to avoid caching issues caused by `classpath.index` file
      // showing up in build/classes/ and build/resources/ directories.
      // See https://github.com/JetBrains/gradle-intellij-plugin/issues/1039 for details.
      classpathIndexCleanup.enabled = true

      checkerFramework {
        // Technically, UI thread handling errors can happen outside of the (mostly frontend) modules that depend on IntelliJ,
        // but the risk is minuscule and not worth the extra computational burden in every single build.
        // This might change, however, if/when Checker Framework adds @Heavyweight annotation
        // (https://github.com/typetools/checker-framework/issues/3253).
        checkers += 'org.checkerframework.checker.guieffect.GuiEffectChecker'
      }

      intellij {
        version = intellijVersions.buildTarget
        // No need to instrument Java classes with nullability assertions, we've got this covered much better by Checker
        // (and we don't plan to expose any part of the plugin as an API for other plugins).
        instrumentCode = false
        if (params.withGit4Idea) {
          plugins = ['git4idea']
        }
      }
    }

    applyAliasingChecker = { ->
      if (shouldRunAllCheckers) {
        checkerFramework {
          checkers += 'org.checkerframework.common.aliasing.AliasingChecker'
        }
      }
    }

    applyI18nFormatterAndTaintingCheckers = { ->
      // I18nFormatterChecker and TaintingChecker, like GuiEffectChecker and NullnessChecker, are enabled
      // regardless of `CI` env var/`runAllCheckers` Gradle project property.
      checkerFramework {
        checkers += [
          'org.checkerframework.checker.i18nformatter.I18nFormatterChecker',
          'org.checkerframework.checker.tainting.TaintingChecker'
        ]
        extraJavacArgs += '-Abundlenames=GitMacheteBundle'
      }

      // Apparently, I18nFormatterChecker doesn't see resource bundles in its classpath unless they're defined in a separate module.
      dependencies {
        checkerFramework project(':frontend:base')
      }
    }

    applySubtypingChecker = { ->
      if (shouldRunAllCheckers) {
        dependencies {
          checkerFramework project(':qual')
        }
        checkerFramework {
          checkers += 'org.checkerframework.common.subtyping.SubtypingChecker'
          def qualClassDir = project(':qual').sourceSets.main.output.classesDirs.asPath
          extraJavacArgs += "-ASubtypingChecker_qualDirs=${qualClassDir}"
        }
      }
    }

    applyKotlinConfig = { ->
      compileKotlin {
        // TODO (#785): revert this setting
        // kotlinOptions.allWarningsAsErrors = true

        // Supress the warnings about different version of Kotlin used for compilation
        // than bundled into the `buildTarget` version of IntelliJ.
        // For compilation we use the Kotlin version from the earliest support IntelliJ,
        // and as per https://kotlinlang.org/docs/components-stability.html,
        // code compiled against an older version of kotlin-stdlib should work
        // when a newer version of kotlin-stdlib is provided as a drop-in replacement.
        kotlinOptions.freeCompilerArgs += '-Xskip-metadata-version-check'

        kotlinOptions.jvmTarget = javaMajorVersion
      }
    }

    commonsIO = { ->
      dependencies {
        implementation libs.commonsIO
      }
    }

    ideProbe = { ->
      repositories {
        // Needed for com.intellij.remoterobot:remote-robot
        maven { url 'https://packages.jetbrains.team/maven/p/ij/intellij-dependencies' }
      }

      dependencies {
        // Note that we can't easily use Gradle's `testFixtures` configuration here
        // as it doesn't seem to expose testFixtures resources in test classpath correctly.
        uiTestImplementation project(':testCommon').sourceSets.test.output
        uiTestImplementation libs.bundles.ideProbe
        // This is technically redundant (both since ide-probe pulls in scala-library anyway,
        // and since ide-probe is meant to use in src/uiTest code, not src/test code),
        // but apparently needed for IntelliJ to detect Scala SDK version in the project (it's probably https://youtrack.jetbrains.com/issue/SCL-14310).
        testImplementation libs.scala.library
      }
    }

    jcabiAspects = { ->
      apply plugin: 'io.freefair.aspectj.post-compile-weaving'

      compileJava {
        // Turn off `adviceDidNotMatch` spam warnings
        ajc.options.compilerArgs += '-Xlint:ignore'
      }

      dependencies {
        aspect libs.jcabi.aspects
      }
    }

    jetbrainsAnnotations = { ->
      dependencies {
        compileOnly     libs.jetbrains.annotations
        testCompileOnly libs.jetbrains.annotations
      }
    }

    jgit = { ->
      dependencies {
        implementation libs.jgit
      }
    }

    junit = { ->
      dependencies {
        testImplementation libs.junit
      }
    }

    lombok = { ->
      dependencies {
        compileOnly libs.lombok
        annotationProcessor libs.lombok
        testCompileOnly libs.lombok
        testAnnotationProcessor libs.lombok
      }
    }

    powerMock = { ->
      dependencies {
        testImplementation libs.bundles.powerMock
      }
    }

    reflections = { ->
      dependencies {
        implementation libs.reflections
      }
    }

    slf4jLambdaApi = { ->
      dependencies {
        // It's so useful for us because we are using invocations of methods that potentially consume some time
        // also in debug messages, but this plugin allows us to use lambdas that generate log messages
        // (mainly using string interpolation plugin) and these lambdas are evaluated only when needed
        // (i.e. when the given log level is active)
        implementation libs.slf4j.lambda
      }
    }

    slf4jTestImpl = { ->
      // We only need to provide an SLF4J implementation in the contexts which depend on the plugin but don't depend on IntelliJ.
      // In our case, that's solely the tests of backend modules.
      // In other contexts that require an SLF4J implementation (buildPlugin, runIde, UI tests),
      // an SLF4J implementation is provided by IntelliJ.
      // Note that we don't need to agree the SLF4J implementation version here with slf4j-api version pulled in by our dependencies (like JGit)
      // since the latter is excluded (see the comment to `exclude group: 'org.slf4j'` for more nuances).
      // The below dependency provides both slf4j-api and an implementation, both already in the same version.
      // Global exclusion on slf4j-api does NOT apply to tests since it's only limited to `runtimeClasspath` configuration.
      dependencies {
        testRuntimeOnly libs.slf4j.simple
      }
    }

    vavr = { ->
      dependencies {
        // Unlike any other current dependency, Vavr classes are very likely to end up in binary interface of the depending subproject,
        // hence it's better to just treat Vavr as an `api` and not `implementation` dependency by default.
        api libs.vavr
      }
    }
  }
}


subprojects {
  // This is necessary to make sure that `buildPlugin` task puts jars of all relevant subprojects into the final zip.
  // No need to include near-empty (only with META-INF/MANIFEST.MF) jars
  // for subprojects that don't have any production code.
  if (sourceSets.main.allSource.srcDirs.findAll { file(it).exists() }) {
    rootProject.dependencies {
      implementation(project)
    }
  }

  // By default, the jar name will be formed only from the last segment of subproject path.
  // Since these last segments are NOT unique (there are many `api`s and `impl`s),
  // the effective jar name will be something like api.jar, api_1.jar, api_2.jar etc.,
  // which is suboptimal.
  // Let's use full name like frontend-ui-api.jar instead.
  archivesBaseName = path.replaceFirst(":", "").replaceAll(":", "-")
}


// Root project config

group 'com.virtuslab'

apply plugin: 'org.ajoberstar.grgit'
apply from: 'version.gradle'

if (ciBranch == 'master') {
  version PROSPECTIVE_RELEASE_VERSION  // more precisely, "soon-to-happen-in-this-pipeline release version" in case of master builds

} else if (!file('.git').exists()) {
  // To make sure it's safe for Docker image builds where .git folder is unavailable
  version "${PROSPECTIVE_RELEASE_VERSION}-SNAPSHOT"

} else {
  def maybeSnapshot = ciBranch == 'develop' ? '' : '-SNAPSHOT'

  def git = org.ajoberstar.grgit.Grgit.open(currentDir: projectDir)
  def lastTag = git.tag.list().sort { it.dateTime }.last()
  def commitsSinceLastTag = grgit.log(includes: ['HEAD'], excludes: [lastTag.fullName])
  def maybeCommitCount = commitsSinceLastTag.empty ? '' : '-' + commitsSinceLastTag.size()
  def shortCommitHash = git.head().abbreviatedId
  def maybeDirty = git.status().clean ? '' : '-dirty'
  git.close()

  version "${PROSPECTIVE_RELEASE_VERSION}${maybeCommitCount}${maybeSnapshot}+git.${shortCommitHash}${maybeDirty}"
}



dependencies {
  // Checker is needed on root project runtime (not just compile-time) classpath for ArchUnit tests
  testImplementation libs.checker.qual

  testImplementation libs.archunit
}


apply plugin: 'org.jetbrains.intellij'

intellij {
  instrumentCode = false
  pluginName = 'git-machete-intellij-plugin'
  version = intellijVersions.buildTarget

  plugins = ['git4idea'] // Needed solely for ArchUnit
}

if (!isCI) {
  // The output of this task is for some reason very poorly cached,
  // and the task takes a significant amount of time,
  // while the index of searchable options is of little use for local development.
  buildSearchableOptions.enabled = false
}

patchPluginXml {
  // `sinceBuild` is exclusive when we are using `*` in version but inclusive when without `*`
  sinceBuild = IntellijVersionHelper.toBuildNumber(intellijVersions.earliestSupportedMajor)

  // In `untilBuild` situation is inverted: it's inclusive when using `*` but exclusive when without `*`
  untilBuild = IntellijVersionHelper.toBuildNumber(intellijVersions.latestSupportedMajor) + '.*'

  // Note that the first line of the description should be self-contained since it is placed into embeddable card:
  // see e.g. https://plugins.jetbrains.com/search?search=git%20machete
  pluginDescription = file("$rootDir/DESCRIPTION.html").text

  changeNotes = "<h3>v${rootProject.version}</h3>\n\n" + file("$rootDir/CHANGE-NOTES.html").text
}

runIde {
  maxHeapSize = '4G'
}

import static org.jetbrains.intellij.tasks.RunPluginVerifierTask.FailureLevel.*

runPluginVerifier {
  def maybeEap = intellijVersions.eapOfLatestSupportedMajor
    ? [intellijVersions.eapOfLatestSupportedMajor.replaceAll('-EAP-(CANDIDATE-)?SNAPSHOT', '')]
    : []
  ideVersions = [
    *intellijVersions.latestMinorsOfOldSupportedMajors,
    intellijVersions.latestStable,
    *maybeEap
  ]

  def skippedFailureLevels = EnumSet.of(DEPRECATED_API_USAGES, EXPERIMENTAL_API_USAGES, NOT_DYNAMIC, SCHEDULED_FOR_REMOVAL_API_USAGES)
  failureLevel = EnumSet.complementOf(skippedFailureLevels)
}

publishPlugin {
  token = jetbrainsMarketplaceToken
}


def uiTest = sourceSets.create('uiTest')

configurations {
  uiTestImplementation.extendsFrom testImplementation
  uiTestRuntimeOnly.extendsFrom testRuntimeOnly
}

List<String> uiTestTargets = project.properties.against \
  ? resolveIntelliJVersions(project.properties.against)
  : [intellijVersions.buildTarget]

uiTestTargets.each { version ->
  tasks.register("uiTest_${version}", Test) {
    description = 'Runs UI tests.'
    group = 'verification'

    testClassesDirs = uiTest.output.classesDirs
    classpath = configurations.uiTestRuntimeClasspath + uiTest.output

    dependsOn ':buildPlugin'

    systemProperty 'ui-test.intellij.version', version
    systemProperty 'ui-test.plugin.path', buildPlugin.outputs.files[0].path

    // TODO (#945): caching of UI test results doesn't work in the CI anyway
    if (!isCI) {
      outputs.upToDateWhen { false }
    }

    if (project.properties.tests) {
      filter {
        includeTestsMatching "*.*${project.properties.tests}*"
      }
    }

    if (project.hasProperty('headless')) {
      environment 'IDEPROBE_DISPLAY', 'xvfb'
      environment 'IDEPROBE_PATHS_SCREENSHOTS', System.getProperty("user.home") + '/.ideprobe-uitests/' + '/artifacts/uiTest' + version + '/screenshots'
      if (isCI) {
        environment 'IDEPROBE_PATHS_BASE', System.getProperty("user.home") + '/.ideprobe-uitests/'
      }
    }

    testLogging {
      events += [TestLogEvent.STANDARD_OUT, TestLogEvent.STANDARD_ERROR]
    }
  }
}

// Cannot use `task uiTest(type: Test)` syntax due to the name conflict with `def uiTest` above.
tasks.register('uiTest') {
  dependsOn tasks.matching { Task task -> task.name.startsWith("uiTest_") }
}

ideProbe()
